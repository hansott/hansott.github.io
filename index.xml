<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hans Ott</title>
    <link>https://hansott.github.io/</link>
    <description>Recent content on Hans Ott</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 21 Aug 2017 09:00:00 +0200</lastBuildDate>
    
	<atom:link href="https://hansott.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>5 simple rules for simpler code</title>
      <link>https://hansott.github.io/post/5-simple-rules-for-simpler-code/</link>
      <pubDate>Mon, 21 Aug 2017 09:00:00 +0200</pubDate>
      
      <guid>https://hansott.github.io/post/5-simple-rules-for-simpler-code/</guid>
      <description>I wrote a blogpost on our company blog about simple code. Let me know what you think!
 We as developers care about simple code. Simple code makes it easier to read and debug code which will allow you to build new features and fix bugs faster.
https://engagor.github.io/blog/2017/08/21/simple-rules-for-simpler-code/
 </description>
    </item>
    
    <item>
      <title>Building a sliding window rate limiter with Redis</title>
      <link>https://hansott.github.io/post/building-a-sliding-window-rate-limiter-with-redis/</link>
      <pubDate>Fri, 02 Jun 2017 09:00:00 +0200</pubDate>
      
      <guid>https://hansott.github.io/post/building-a-sliding-window-rate-limiter-with-redis/</guid>
      <description>I wrote a blogpost on our company blog about building a sliding rate limiter with Redis. Let me know what you think!
 For our Instagram crawler we needed a system to keep track of the amount of API calls we did to prevent us from hitting the rate limits. We could of course perform our HTTP requests without checking rate limits upfront, and wait until we get a 429 OAuthRateLimitException from Instagram, but that would exhaust our tokens and block us from talking efficiently to their API.</description>
    </item>
    
    <item>
      <title>Programmatically login user with symfony/security in Silex</title>
      <link>https://hansott.github.io/post/programmatically-login-user-with-symfony-security-in-silex/</link>
      <pubDate>Mon, 02 May 2016 20:40:00 +0200</pubDate>
      
      <guid>https://hansott.github.io/post/programmatically-login-user-with-symfony-security-in-silex/</guid>
      <description>Last night I was experimenting with Silex and I needed a register/login form. Silex comes with a SecurityServiceProvider which gives you the power of the symfony/security component. But I couldn&amp;rsquo;t figure out how to programmatically login the user after registration. So here&amp;rsquo;s my solution:
The registration controller:
&amp;lt;?php use Silex\Application; use Symfony\Component\HttpFoundation\Request; final class RegistrationController { // ... public function register(Request $request, Application $app) { $email = $request-&amp;gt;get(&amp;#39;email&amp;#39;); $password = $request-&amp;gt;get(&amp;#39;password&amp;#39;); // validation logic.</description>
    </item>
    
    <item>
      <title>A simple, declarative, and composable way to fetch data for React components</title>
      <link>https://hansott.github.io/post/a-simple-declarative-and-composable-way-to-fetch-data-for-react-components/</link>
      <pubDate>Mon, 14 Mar 2016 10:04:00 +0200</pubDate>
      
      <guid>https://hansott.github.io/post/a-simple-declarative-and-composable-way-to-fetch-data-for-react-components/</guid>
      <description>Introducing React Refetch  We obviously needed to standardize on a way to load data, but we werenâ€™t really happy with any of our existing methods. Loading data into state made components smarter and more mutable than they needed to be, and these problems only became worse with more data sources. We liked the general idea of unidirectional flow and division of responsibility that the Flux architecture introduced, but it also brought a lot of boilerplate and complexity with it.</description>
    </item>
    
    <item>
      <title>Add homestead MySQL as data source in PhpStorm</title>
      <link>https://hansott.github.io/post/add-homestead-mysql-as-data-source-in-phpstorm/</link>
      <pubDate>Sun, 13 Mar 2016 11:34:28 +0200</pubDate>
      
      <guid>https://hansott.github.io/post/add-homestead-mysql-as-data-source-in-phpstorm/</guid>
      <description>To be able to work with your databases in PhpStorm, you should define them as data sources. Data sources provide the basis for SQL coding assistance and code validation.
 Laravel Homestead is an official, pre-packaged Vagrant box that provides you a wonderful development environment without requiring you to install PHP, HHVM, a web server, and any other server software on your local machine.
 Select View | Tool Windows | Database, click on the + button and choose Data Source | MySQL:</description>
    </item>
    
  </channel>
</rss>